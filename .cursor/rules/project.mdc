---
description: OVS IntelliJ IDEA 插件 - LSP 客户端实现
alwaysApply: true
---

# OVS IntelliJ IDEA 插件

## 项目定位
为 OVS (Object-oriented View Syntax) 语言提供 IntelliJ IDEA 的完整 IDE 支持，作为 LSP 客户端连接到 OVS 语言服务器。

**核心价值：**
- 完整的 ES6 语法高亮（基于 JFlex）
- LSP 语义高亮（Semantic Tokens）
- 代码补全、跳转、诊断（通过 LSP）
- 与 IntelliJ 平台深度集成

## 当前阶段
STAGE_3_INTEGRATION

## 当前状态
- ✅ 文件类型注册：.ovs 文件识别
- ✅ 语法高亮：完整 ES6 支持（基于 JFlex，230行词法规则）
- ✅ LSP 客户端：连接到语言服务器
- ✅ Semantic Tokens 支持：配置完成
- ⚠️ 调试中：Semantic Tokens 触发机制
- 版本：1.0-SNAPSHOT
- 技术栈：Kotlin + JFlex + IntelliJ Platform 2025.2.1

## 下一步行动
1. 修复 Semantic Tokens 请求触发问题
2. 完善代码补全功能
3. 添加错误诊断显示
4. 优化 LSP 通信性能

---

# 【核心需求层】

## 核心功能（用户能做什么）

### IDE 功能
- **语法高亮**：完整 ES6 关键字、字面量、运算符着色（本地 Lexer）
- **语义高亮**：基于 LSP 的类型、变量、函数着色（Semantic Tokens）
- **错误诊断**：实时语法和语义错误提示（通过 LSP）
- **代码补全**：智能提示（通过 LSP）
- **跳转定义**：Ctrl+Click 跳转（通过 LSP）
- **格式化**：代码自动格式化（通过 LSP）

### 支持的 OVS 语法
- 声明式 UI：`div { "content" }`
- 组件声明：`ovsView ComponentName ({props}) : div { ... }`
- `#{}` 不渲染块：隔离纯逻辑代码
- 完整 ES6 语法：let、const、class、async/await 等

## 技术方向（设备支持、性能要求）

### 运行环境
- **IntelliJ IDEA**：2025.2.1+ (Ultimate 或 Community)
- **依赖模块**：
  - `com.intellij.modules.platform`
  - `com.intellij.modules.lsp`
- **JDK**：17+

### 性能要求
- **语法高亮**：< 1ms（本地 JFlex Lexer）
- **LSP 通信**：< 100ms（异步）
- **内存占用**：< 50MB（插件自身）

## 数据需求（存什么、怎么存）

### 配置文件
- **build.gradle.kts**：构建配置
- **plugin.xml**：插件元数据和扩展点注册
- **gradle.properties**：Gradle 属性

### 源代码
- **词法规则**：`src/main/grammar/Es6.flex`（230行）
- **生成代码**：`src/main/gen/lexer/_Es6Lexer.java`（500行，自动生成）
- **Kotlin 源码**：`src/main/kotlin/`
  - 文件类型、语言定义
  - LSP 支持提供者
  - 语法高亮器

### 临时数据
- **构建输出**：`build/` 目录
- **IDEA 沙箱**：`build/idea-sandbox/`

## 优先级（第一版做什么）

**P0 - 基础设施（已完成）：**
- ✅ 文件类型注册（OvsFileType）
- ✅ 语言定义（OvsLanguage）
- ✅ JFlex 词法规则（Es6.flex）
- ✅ 语法高亮器（OvsSyntaxHighlighter）

**P1 - LSP 集成（进行中）：**
- ✅ LSP 服务器连接（OvsLspServerSupportProvider）
- ✅ Semantic Tokens 配置
- ⚠️ Semantic Tokens 触发修复
- 🔄 代码补全优化
- 🔄 错误诊断显示

**P2 - 高级功能（规划中）：**
- ⏳ 重构功能（重命名、提取变量）
- ⏳ 调试器集成
- ⏳ Source Map 支持

---

# 【细节实现层】

## 文件结构

```
ovs-lsp-intellij/
├── build.gradle.kts                    # 构建配置（JFlex + Plugin）
├── src/main/
│   ├── grammar/
│   │   └── Es6.flex                    # 词法规则（230行）
│   ├── gen/
│   │   └── lexer/_Es6Lexer.java        # 自动生成（500行 DFA）
│   ├── kotlin/com/alamhubb/ovs/testovs/
│   │   ├── lexer/
│   │   │   └── Es6TokenTypes.kt        # Token 类型定义（150行）
│   │   ├── OvsFileType.kt              # 文件类型
│   │   ├── OvsLanguage.kt              # 语言定义
│   │   ├── OvsFile.kt                  # PSI 文件
│   │   ├── OvsLspServerSupportProvider.kt  # LSP 支持（198行）
│   │   ├── OvsSyntaxHighlighter.kt     # 语法高亮器
│   │   ├── OvsSyntaxHighlighterFactory.kt
│   │   └── OvsTypedHandler.kt          # 输入处理
│   └── resources/
│       ├── META-INF/plugin.xml         # 插件配置
│       └── icons/ovs.png               # 文件图标
├── test-semantic-tokens.ovs            # 测试文件
└── test-syntax-highlighting.ovs        # 测试文件
```

## 核心技术实现

### 1. 语法高亮（JFlex + Lexer）

#### 工作流程
```
.ovs 文件
  ↓
JFlex Lexer (_Es6Lexer.java)
  ↓
Token 流（LET, CONST, STRING_LITERAL, ...）
  ↓
OvsSyntaxHighlighter（映射颜色）
  ↓
编辑器着色显示
```

#### 支持的 ES6 特性

**关键字（60+）：**
```
ES5: var, function, if, else, for, while, return, throw, try, catch, ...
ES6: let, const, class, extends, super, import, export, async, await, ...
```

**字面量：**
```javascript
// 数字（所有格式）
123, 123.45, 1.23e10    // 十进制
0xFF, 0x1a2b            // 十六进制
0o777, 0o644            // 八进制（ES6）
0b1010, 0b1111          // 二进制（ES6）

// 字符串（3种）
"double quotes"
'single quotes'
`template ${variable}`   // 模板字符串（ES6）

// 正则表达式
/pattern/gi
```

**运算符（40+）：**
```javascript
+, -, *, /, %, ++, --                // 算术
<, >, <=, >=, ==, !=, ===, !==      // 比较
!, &&, ||                            // 逻辑
=, +=, -=, *=, /=                   // 赋值
=>, ...                              // ES6
```

#### 性能指标

| 指标 | 数值 |
|------|------|
| 响应时间 | < 1ms（本地词法分析） |
| 内存占用 | 极低（查表法） |
| 准确度 | 100%（基于 ES6 标准） |
| 文件大小支持 | 无限制 |

#### Es6.flex 词法规则（核心片段）

```flex
%public
%class _Es6Lexer
%implements FlexLexer
%unicode
%function advance
%type IElementType

// 关键字
"let"        { return Es6TokenTypes.LET; }
"const"      { return Es6TokenTypes.CONST; }
"class"      { return Es6TokenTypes.CLASS; }
"async"      { return Es6TokenTypes.ASYNC; }
"await"      { return Es6TokenTypes.AWAIT; }

// 字面量
{IDENTIFIER}      { return Es6TokenTypes.IDENTIFIER; }
{STRING_LITERAL}  { return Es6TokenTypes.STRING_LITERAL; }
{NUMERIC_LITERAL} { return Es6TokenTypes.NUMERIC_LITERAL; }

// 运算符
"=>"         { return Es6TokenTypes.ARROW; }
"..."        { return Es6TokenTypes.SPREAD; }
```

#### OvsSyntaxHighlighter.kt（颜色映射）

```kotlin
override fun getTokenHighlights(tokenType: IElementType): Array<TextAttributesKey> {
    return when (tokenType) {
        // 关键字
        Es6TokenTypes.LET, Es6TokenTypes.CONST, 
        Es6TokenTypes.CLASS, Es6TokenTypes.ASYNC -> 
            arrayOf(DefaultLanguageHighlighterColors.KEYWORD)
        
        // 字符串
        Es6TokenTypes.STRING_LITERAL -> 
            arrayOf(DefaultLanguageHighlighterColors.STRING)
        
        // 数字
        Es6TokenTypes.NUMERIC_LITERAL -> 
            arrayOf(DefaultLanguageHighlighterColors.NUMBER)
        
        // 注释
        Es6TokenTypes.LINE_COMMENT, Es6TokenTypes.BLOCK_COMMENT -> 
            arrayOf(DefaultLanguageHighlighterColors.LINE_COMMENT)
        
        else -> TextAttributesKey.EMPTY_ARRAY
    }
}
```

### 2. LSP 集成（Semantic Tokens）

#### 关键配置（plugin.xml）

```xml
<extensions defaultExtensionNs="com.intellij">
    <!-- 文件类型 -->
    <fileType
        name="Ovs File"
        implementationClass="com.alamhubb.ovs.testovs.OvsFileType"
        fieldName="INSTANCE"
        language="ovs"
        extensions="ovs"/>
    
    <!-- LSP 支持（核心） -->
    <platform.lsp.serverSupportProvider 
        implementation="com.alamhubb.ovs.testovs.OvsLspServerSupportProvider"/>
    
    <!-- 输入处理器 -->
    <typedHandler 
        implementation="com.alamhubb.ovs.testovs.OvsTypedHandler"/>
    
    <!-- ❌ 不要注册 parserDefinition（会阻止 LSP Semantic Tokens）
    <lang.parserDefinition ... />
    -->
</extensions>
```

**为什么不注册 `parserDefinition`？**

IntelliJ 的语言支持优先级：
1. **本地 PSI（最高优先级）** - 如果有 `parserDefinition`，使用本地解析
2. **LSP 模式** - 没有 `parserDefinition` 时，依赖 LSP 服务器
3. **混合模式** - 同时有时，本地优先，LSP Semantic Tokens 被忽略

因此，**纯 LSP 语言必须不注册 `parserDefinition`**。

#### OvsLspServerSupportProvider.kt（核心实现）

```kotlin
class OvsLspServerSupportProvider : LspServerSupportProvider {
    override fun fileOpened(
        project: Project,
        file: VirtualFile,
        descriptor: LspServerDescriptor
    ) {
        if (file.extension == "ovs") {
            descriptor.lspServerStarter.ensureServerStarted(descriptor)
        }
    }

    override fun createLspServerDescriptor(
        project: Project,
        root: VirtualFile
    ): LspServerDescriptor? {
        return object : LspServerDescriptor(project, "OVS Language Server") {
            override fun createCommandLine(): GeneralCommandLine {
                val serverPath = findServerPath()
                return GeneralCommandLine().apply {
                    withExePath("node")
                    addParameter(serverPath)
                    addParameter("--stdio")
                }
            }
            
            override fun createInitializationOptions(): JsonObject {
                return JsonObject().apply {
                    addProperty("locale", "zh-CN")
                }
            }
        }
    }

    override val lspCustomization: LspCustomization =
        object : LspCustomization() {
            override val semanticTokensCustomizer: LspSemanticTokensCustomizer =
                object : LspSemanticTokensSupport() {
                    override val tokenTypes = listOf(
                        "namespace", "class", "enum", "interface",
                        "typeParameter", "type", "parameter",
                        "variable", "property", "enumMember",
                        "function", "method"
                    )

                    override val tokenModifiers = listOf(
                        "declaration", "readonly", "static",
                        "async", "defaultLibrary", "local"
                    )

                    override fun getTextAttributesKey(
                        tokenType: String,
                        modifiers: List<String>
                    ): TextAttributesKey? {
                        return when (tokenType) {
                            "class" -> DefaultLanguageHighlighterColors.CLASS_NAME
                            "interface" -> DefaultLanguageHighlighterColors.INTERFACE_NAME
                            "function", "method" -> DefaultLanguageHighlighterColors.FUNCTION_CALL
                            "variable" -> DefaultLanguageHighlighterColors.LOCAL_VARIABLE
                            "parameter" -> DefaultLanguageHighlighterColors.PARAMETER
                            "property" -> DefaultLanguageHighlighterColors.INSTANCE_FIELD
                            "type" -> DefaultLanguageHighlighterColors.CLASS_REFERENCE
                            else -> null
                        }
                    }
                }
        }
    
    private fun findServerPath(): String {
        // 查找语言服务器路径
        val possiblePaths = listOf(
            "../test-volar-copy/langServer/dist/server.js",
            "../test-volar-copy/langServer/src/server.ts"
        )
        
        return possiblePaths.firstOrNull { File(it).exists() }
            ?: throw IllegalStateException("LSP server not found")
    }
}
```

#### LSP 通信流程

```
IntelliJ IDEA
  ↓ 打开 .ovs 文件
OvsLspServerSupportProvider
  ↓ 启动 Node.js 进程
Language Server (langServer/dist/server.js)
  ↓ LSP 协议通信
  
1. initialize 请求
   ← capabilities（支持的功能列表）
   
2. textDocument/didOpen 通知
   → 文档内容
   
3. textDocument/semanticTokens/full 请求
   ← Semantic Tokens 数据
   
4. LspSemanticTokensSupport
   ↓ 映射颜色
编辑器显示
```

### 3. 已知问题与解决方案

#### ❌ Semantic Tokens 不触发

**问题：** 客户端不发送 `textDocument/semanticTokens/full` 请求

**可能原因：**
1. IntelliJ 需要用户交互（编辑内容）才触发
2. 需要 `workspace.semanticTokens.refreshSupport = true`
3. 配置或实现问题

**调试步骤：**

1. **启用详细日志**
   - `Help > Diagnostic Tools > Debug Log Settings`
   - 添加：
     ```
     #com.intellij.platform.lsp
     #com.intellij.platform.lsp.impl.LspServerImpl
     #com.intellij.platform.lsp.impl.requests
     ```
   - 重启 IDE

2. **查看日志**
   - `Help > Show Log in Explorer`
   - 搜索：`semanticTokens`、`Ovs`、`LSP request`

3. **测试触发**
   - 打开 `.ovs` 文件
   - **在编辑器中输入内容**（关键）
   - 观察服务端日志

**临时解决方案：**
- JFlex 语法高亮已完整支持（足够日常使用）
- 继续调试 LSP Semantic Tokens

---

## 开发命令

### 生成 Lexer
```bash
cd ovs-lsp-intellij

# 修改 Es6.flex 后必须执行
./gradlew generateLexer

# 输出：src/main/gen/lexer/_Es6Lexer.java
```

### 构建插件
```bash
# 完整构建
./gradlew buildPlugin

# 输出：build/distributions/test1ovs-1.0-SNAPSHOT.zip
```

### 运行测试 IDE
```bash
./gradlew runIde

# 启动沙箱 IntelliJ IDEA
# 自动加载插件
```

### 清理
```bash
./gradlew clean

# 删除 build/ 目录
```

### 完整流程
```bash
# 1. 修改词法规则
vim src/main/grammar/Es6.flex

# 2. 重新生成
./gradlew generateLexer

# 3. 构建
./gradlew buildPlugin

# 4. 测试
./gradlew runIde
```

---

## 测试与验证

### 1. 语法高亮测试

**测试文件：** `test-syntax-highlighting.ovs`

```javascript
// ES6 语法高亮测试
let userName = "Alice"
const userAge = 25

class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  
  async fetchData() {
    const response = await fetch('/api/user')
    return response.json()
  }
}

import { User } from './models'
export default Person

const message = `Hello, ${userName}!`
const double = x => x * 2
const { name, age } = user
const newArray = [...oldArray, 4, 5]
```

**预期效果：**
- ✅ 关键字 → 紫色/橙色
- ✅ 字符串 → 绿色
- ✅ 数字 → 蓝色
- ✅ 注释 → 灰色

### 2. Semantic Tokens 测试

**测试文件：** `test-semantic-tokens.ovs`

```javascript
class UserManager {
  private users: User[]
  
  async getUser(id: number): Promise<User> {
    return this.users.find(u => u.id === id)
  }
}
```

**预期效果（待修复）：**
- ✅ `UserManager` → CLASS_NAME 颜色
- ✅ `getUser` → FUNCTION_CALL 颜色
- ✅ `users`, `id` → LOCAL_VARIABLE 颜色

### 3. LSP 连接测试

**步骤：**
1. 运行 `./gradlew runIde`
2. 打开 `.ovs` 文件
3. 查看 IDE 日志（Help > Show Log）

**预期日志：**
```
LSP server starting: node .../server.js --stdio
LSP server started successfully
textDocument/didOpen sent
Language ID: ovs
```

---

## 快速开始

### 1. 环境准备

```bash
# 克隆项目
cd ovs-lsp-all/ovs-lsp-intellij

# 检查 JDK 版本（需要 17+）
java -version

# 检查 Gradle
./gradlew --version
```

### 2. 生成并构建

```bash
# 生成 Lexer
./gradlew generateLexer

# 构建插件
./gradlew buildPlugin
```

### 3. 运行测试

```bash
# 启动测试 IDE
./gradlew runIde

# 在测试 IDE 中：
# 1. File > Open > 选择 test-syntax-highlighting.ovs
# 2. 验证语法高亮
# 3. 编辑内容，观察 Semantic Tokens
```

### 4. 安装到本地 IDE

```bash
# 构建 zip
./gradlew buildPlugin

# 在 IntelliJ IDEA 中：
# Settings > Plugins > ⚙️ > Install Plugin from Disk
# 选择：build/distributions/test1ovs-1.0-SNAPSHOT.zip
```

---

## 依赖的服务端

### 语言服务器
- **项目**：`../test-volar-copy/langServer`
- **启动命令**：`node dist/server.js --stdio`
- **协议**：LSP (Language Server Protocol)
- **功能**：
  - Semantic Tokens
  - 代码补全
  - 跳转定义
  - 错误诊断

### OVS 编译器
- **项目**：`../test-volar-copy/ovs`
- **作用**：编译 .ovs 文件为 JavaScript
- **集成**：通过语言服务器间接使用

---

## 文档体系

### 本项目文档
1. **`.cursor/rules/project.mdc`** - 📌 完整项目信息（本文件）
2. **`.cursor/rules/README_DOCS.md`** - 📖 文档说明
3. **`ES6_SYNTAX_HIGHLIGHTING_GUIDE.md`** - 📚 JFlex 实现详细指南
4. **`SOLUTION_SEMANTIC_TOKENS.md`** - 📚 LSP 问题解决方案

### 相关项目文档
- **test-volar-copy/.cursor/rules/project.mdc** - 语言服务器总体
- **test-volar-copy/ovs/.cursor/rules/project.mdc** - OVS 编译器

---

# 【变更记录】

## 2025-10-29 [文档重构]
- ✅ 分离客户端和服务端文档
- ✅ 专注于 IntelliJ 插件实现
- ✅ 完善 LSP 集成说明
- ✅ 添加详细的调试指南

## 历史记录
- ✅ JFlex ES6 语法高亮实现（230行词法规则）
- ✅ LSP 服务器连接（OvsLspServerSupportProvider）
- ✅ Semantic Tokens 配置（颜色映射）
- ⚠️ Semantic Tokens 触发问题（调试中）

---

**IntelliJ IDEA 插件 | LSP 客户端 | 最后更新: 2025-10-29**
